- Figure out how to expand canvas to size of its parent (shouldn't have to explicitly set width/height on canvas)
- Change "onclick" references to "onpress"
- Need arrow icons for shift and del
- Logic for CanvasButton._draw_button() should not use the bounding box of the text when absolute with and height
    are specified. Because the bounding box will vary depending upon the text. Should use the centre point instead.
- Installer for Mac/Windows/Linux?
- Message vertical alignment/centering in dialog doesn't work so well. Review this logic.
- May need special indicator for final 9 bonus puzzles (currently part of level 3)?
- Hide mouse cursor
- Full screen when on raspberry pi (platform specific setting)
- Iconise all buttons
- Round corners of all buttons
- Create highscore page
- Put a delayed callback in that releases a pressed button after 1s if it hasn't already been released


Blog
----

Section: Building Kanoodle Genius
    - Set the scene - why this came to being (my daughter is smarter than me)
    - Technology choices:
        - Tkinter (yes this is built with Tkinter)
            - Didn't require full animation support of PyGame - this is just a puzzle after all
        - Peewee
        - SQLIte
        - Python imaging library (why needed)
        - Explain rationale for the above choices (e.g. wanted to work at lunchtimes on my work PC and didn't want to
            install loads of dependencies which might have broken my dev env and made me unpopular - e.g. so not PyGame).
    - The domain model, key concepts
        - Simple diagram
    - Basic behaviours, using static methods where it made sense.
        Why?
            - Well named coarse grained methods easier to work with at the layers above
            - Easier to understand less mental load needed
            - Don't expose ORM stuff to the UI layer, even though Peewee nicely abstracts
            - Easier to test
    - The UI, key concepts
        - Core screens
            - Masterscreen coordinates between other screens, hosts the callbacks
        - Basic frame layout on game screen
        - Used a inheritance approach rather than composition (e.g. game screens extend Frame)
        - Basic reusable components created for button and dialog - as I knew I'd be using them all over the place
        - On screen keyboard
        - Graphics. Just use GIMP to create some spheres.
        - Mention platform specific tweaks. Used Python's platform in order to have specific font and position
            overrides for the Mac (Linux the default).
        - Platform specific tweaks for raspberry pi: hide the mouse pointer, default to fullscreen
    - Putting it all together
        - Installing on the Raspberry PI touchscreen
        - Bought the touchscreen, case, raspberry pi model B, power supply, SD card preloaded with Raspbian. Cost $100?
            - Work very kindly supplied $100 of Amazon vouchers as Christmas gift
        - Used the instructions here: https://www.makeuseof.com/tag/setup-raspberry-pi-touchscreen/
            - Mention lcd_rotate=2 in /boot/config.txt
        - Used platform specific overrides to detect if on touchscreen and:
            - Go full screen automatically
            - Hide the mouse pointer

Section: Solving Kanoodle Genius
    - My daughter is smarter than me. This is what originally inspired me to build the game.
    - The approach I took:
        - Once the key domain concepts in place:
            - The object model
            - Key behaviours: rotate, flip, place noodle
        ... it was simply a case of iterating all of the unoccupied holes on the board and trying each noodle in
            each hole, rotating and flipping, until a position was found and the board correctly filled.
            This is the brute force approach.
    - Problems with the approach:
        - Ineffcient, programmatically
        - Talk about the times involved:
            - Level 1 puzzles took a few ms
            - Level 2 puzzles a few seconds to a few minutes
            - Level 3 puzzles a few minutes to several days! (e.g. puzzle 32)
        - Used cProfile to identify slow areas and optimse accordingly
            - caching target positions in place()
        - Inefficient, algorithmically
            - No special handling for holes surrounding the edge of the board
            - Unable to identify holes up front which a noodle could never fit, and thus would try these holes
                anyway wasting iterations
    - May need to checkout the solving branch and re-run a solve, using cProfile, and revisit some of the inefficiencies
    - Ultimately I decided that I couldn't solve on the fly due to the latencies involved. Would have to pre-solve and
        store the solutions in the database so it would run quickly from the player's point of view.
    - How could I have done better with my solving algorithm? It felt natural to just use the functionality offered
        by the domain model (e.g. rotate, place(), etc), but perhaps something different was required.